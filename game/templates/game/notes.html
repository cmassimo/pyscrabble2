{% extends 'base.html' %}
{% load staticfiles %}

{% block pagetitle %} Home {% endblock %}

{% block content %}
    <div class="fallback-message">
      <p>Your browser <b>doesn't support the features required</b> by impress.js, so you are presented with a simplified version of this  presentation.</p>
      <p>For the best experience please use the latest <b>Chrome</b>, <b>Safari</b> or <b>Firefox</b> browser.</p>
    </div>

    <div id="impress" data-transition-duration="1500"><div class="step" step="0" data-x="0" data-y="0"><h1 id="pyscrabble2">Pyscrabble2</h1><p>un progetto di:</p><h2 id="carlo-maria-massimo">Carlo Maria Massimo</h2><h2 id="giorgio-piantella">Giorgio Piantella</h2></div><div class="step" step="1" data-x="1600" data-y="0"><h1 id="il-progetto">Il progetto</h1><p>Il progetto &#xE8; consistito nel <strong>porting ed estensione</strong> di un progetto esistente, <a href="https://code.google.com/p/sharpscrabble/">sharpscrabble</a>, scritto in F#.</p><p>Il porting &#xE8; stato effettuato in <strong>Python</strong> per questioni di <strong>efficienza</strong> unita alla semplicit&#xE0; d'uso del linguaggio.</p><p>La realizzazione ha richiesto all'incirca un <em>centinaio di ore</em>, suddivise tra:</p><ul><li>analisi del software esistente</li><li>porting</li><li>implementazione della gui</li><li>estensione della strategia di ricerca</li></ul></div><div class="step" step="2" data-x="3200" data-y="0"><h1 id="il-software">Il software</h1><p>Il software implementa le seguenti strategie di ricerca:</p><ul><li>Brute-force</li><li>Hill climbing classico con riavvio casuale limitato</li><li>Brute force con minimax su 4 livelli di profondit&#xE0; e 3 di ampiezza</li></ul></div><div class="step" step="3" data-x="4800" data-y="0"><p>Tuttle le strategie fanno capo ad una struttura dati <strong>dizionario</strong>, caricata a partire da una wordlist di circa <strong>280000 parole valide</strong> dello Scrabble italiano.</p><p>La struttura dati &#xE8; composta da coppie chiave/valore del tipo:</p><p><code>'ceiimnnooprs': ['comprensioni', 'ricompensino']</code></p><p>che permette, data una sequenza ordinata di lettere di <strong>recuperare tutte le possibili parole valide ottenibili in tempo costante</strong>.</p></div><div class="step" step="4" data-x="6400" data-y="0"><p>Gli algoritmi di ricerca sono stati mantenuti piuttosto naive per non incidere troppo sul tempo di esecuzione.
Si &#xE8; deciso pertanto di:</p><ul><li>non implementare la generazione di  mosse con la lettera jolly '*'</li><li>non implementare agganci paralleli ad una parola gi&#xE0; presente</li></ul><p>Queste due limitazioni restringono lo spazio di ricerca.</p></div><div class="step" step="5" data-x="8000" data-y="0"><h1 id="brute-force">Brute-force</h1><p>Questa strategia si compone dei seguenti passi:</p><ul><li>generazione di tutte le mosse a partire da tutte le parole valide (nel dizionario) generabili con:<ul><li>le lettere nel rack del giocatore corrente pi&#xF9;</li><li>ognuna delle lettere nelle caselle gi&#xE0; occupate sulla tavola</li></ul></li><li>validazione delle mosse sulla tavola (posizione, side-effects)</li><li>calcolo del punteggio delle mosse</li><li>restituzione della mossa con utilit&#xE0; maggiore a seconda della funzione di utilit&#xE0; scelta.</li></ul><p>Questa strategia garantisce buoni risultati in termini di punteggi sacrificando l'efficienza.</p></div><div class="step" step="6" data-x="9600" data-y="0"><h1 id="hill-climbing">Hill climbing</h1><p>Ricerca locale, consta dei seguenti passi:</p><ul><li>generazione della prossima mossa disponibile secondo gli stessi criteri della ricerca BF</li><li>validazione e calcolo del punteggio della mossa corrente</li><li>confronto con il massimo trovato sino a quel momento</li><li>se il punteggio &#xE8; inferiore al massimo corrente lo ritorna oppure prosegue nella ricerca.</li></ul></div><div class="step" step="7" data-x="11200" data-y="0"><p>Ogni qual volta la procedura ritorna, il risultato viene tenuto da parte, si riavvia la ricerca in maniera <em>casuale</em> e si ripete
l'iterazione.</p><p>Alla fine si ritorna il meglio degli <em>n riavvii</em>, questo per cercare di migliorare la convergenza al massimo globale.</p><p>Delle strategie realizzate &#xE8; la pi&#xF9; performante in termini di <strong>spazio e tempo</strong> ma &#xE8; piuttosto
debole in termini di punteggi realizzati.</p></div><div class="step" step="8" data-x="12800" data-y="0"><h1 id="minimax">Minimax</h1><p>Algoritmo minimax che sfrutta la ricerca brute-force (ripetibile) a profondit&#xE0; 4 ed ampiezza 3 ovvero:</p><ul><li>3 mosse per ogni livello di profondit&#xE0;</li><li>2 mosse per MAX e 2 per MIN</li></ul><p>Con queste impostazioni la ricerca ritorna la mossa iniziale migliore per MAX in termini di minimizzazione del punteggio raggiunto da  MIN.</p><p>Aumentando di un livello l'ampiezza le prestazioni computazionali crollano senza ottenere un guadagno significativo in termini di punteggi, aumentando la profondit&#xE0; di ricerca si notano subito netti miglioramenti di prestazioni (la computazione rimane molto onerosa!)</p></div><div class="step" step="9" data-x="14400" data-y="0"><img src="{% static 'minimax.png' %}" alt="" width="707px" height="544px"></img></div><div class="step" step="10" data-x="16000" data-y="0"><h1 id="funzioni-di-utilita">Funzioni di utilit&#xE0;</h1><p>Sono state implementate 4 funzioni di utilit&#xE0; per determinare la bont&#xE0; di una mossa:</p><ul><li><em>max_score</em>: viene scelta la mossa con punteggio maggiore;</li><li><em>save_common</em>: valuta le mosse che utilizzano solo le tessere con frequenza minore (punteggio maggiore) e sceglie la migliore;</li><li><em>only_play_7s</em>: valuta solo mosse di lunghezza 7 se possibile;</li><li><em>only_play_over_5</em>: valuta solo mosse di lunghezza maggiore di 5 se possible;</li><li><em>use_bonus_squares</em>: valuta solo mosse che massimizzano l'uso di caselle moltiplicatrici una volta posizionate.</li></ul></div><div class="step" step="11" data-x="17600" data-y="0"><h1 id="statistiche-strategie">Statistiche strategie</h1><p>Su un campione di 100 partite per ogni combinazione, con le funzioni di utilit&#xE0; distribuite uniformemente, questi sono stati i risultati:</p><img src="{% static 'table_games.png' %}" alt="" width="547px" height="180px"></img></div><div class="step" step="12" data-x="19200" data-y="0"><h1 id="statistiche-funzioni-utilita">Statistiche funzioni utilit&#xE0;</h1><p>A parit&#xE0; di strategia, su un campione di 100 partite con le funzioni di utilit&#xE0; distribuite uniformemente:</p><img src="{% static 'comportamento_utility.png' %}" alt="" width="806px" height="454px"></img></div><div class="step" step="13" data-x="20800" data-y="0"><h1 id="problemi">Problemi</h1><ul><li>efficienza delle operazioni di validazione e valutazione delle mosse</li><li>ridotta capacit&#xE0; di calcolo non ha consentito indagini con valori troppo elevati (specialmente minimax)</li><li>la strategia HC &#xE8; molto debole, margine di miglioramento</li></ul></div><div class="step" step="14" data-x="22400" data-y="0"><h1 id="todo">Todo</h1><ul><li>modellare in maniera pi&#xF9; efficiente il gioco per il primo punto della slide precedente</li><li>migliorare la strategia di convergenza di HC</li><li>ottimizzare la generazione e valutazione/validazione delle mosse (multithreading)</li></ul></div><div class="step" step="15" data-x="24000" data-y="0"><h1 id="conclusioni">Conclusioni</h1><p>Lo studio di questo gioco da un punto di vista dell'IA ha convalidato la nostra ipotesi che <strong>in questo gioco una strategia meramente greedy paghi</strong>.</p><p>L'unico tipo di strategia che pu&#xF2; competere con la ricerca greedy pura &#xE8; l'approccio minimax, che per&#xF2; (in questo caso) &#xE8; implementato proprio utilizzando la medesima strategia.</p><p>Una modellazione attenta alle problematiche di uso delle risorse di Minimax potrebbe permettere a tale strategia di estendere lo spazio di ricerca mantenendo prestazioni accettabili e di restituire risultati eccellenti in termini di punteggi realizzati.</p></div></div>

      <!-- <div id="overview" class="step" step="10" data-x="21800" data-y="0" scale='10'>
      </div> -->

</div>
{% endblock %}

{% block moar_js %}
  <script src="{% static 'impress.js' %}"></script>
  <script>impress().init();</script>
{% endblock %}
{% block moar_css %}
  <link rel="stylesheet" href="{% static 'impress.css' %}">
{% endblock %}